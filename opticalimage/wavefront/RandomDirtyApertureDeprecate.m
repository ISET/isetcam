function im = RandomDirtyAperture(imagewidth, level)
% RandomDirtyAperture Synthetic dirty aperture with random dots and scratches.
%
% im = RandomDirtyAperture(mask)
% Returns an N x N monochromatic image emulating a dirty aperture plane.
% Specifically, we add disks and polylines of random size and opacity to an
% otherwise white image, in an attempt to model random dust and scratches.
%
% TODO(qiurui): the spatial scale of the random dots and polylines are currently
%   hard-coded in order to match the paper. They should instead be relative to
%   the requested resolution, n.
%
% Arguments
%
% imagewidth: An [N, N]-logical matrix representing the aperture mask. Typically, this
%       should be a centered disk of 1 surrounded by 0.
%
% dirty_level: above or equal to 0.
% Returns
%
% im: An [N, N]-matrix of values in [0, 1] where 0 means completely opaque and 1
%     means completely transparent. The returned matrix is real-valued (i.e., we
%     ignore the phase shift that may be introduced by the "dust" and
%     "scratches").
%
% Required toolboxes: Computer Vision Toolbox.


n = imagewidth;
im = ones([n,n], 'single');

%% Add dots (circles), simulating dust.
num_dots = max(0, round(20 + randn * 5));
num_dots = round(num_dots * level);
max_radius = max(0, 5 + randn * 50);
for i = 1:num_dots
    circle_xyr = rand(1, 3, 'single') .* [n, n, max_radius];
    opacity = 0.5 + rand * 0.5;
    im = insertShape(im, 'FilledCircle', circle_xyr, 'Color', 'black', ...
        'Opacity', opacity);
end

%% Add polylines, simulating scratches.
num_lines = max(0, round(20 + randn * 5));
num_lines = round(num_lines * level);
% max_width = max(0, round(5 + randn * 5));
for i = 1:num_lines
    num_segments = randi(16);
    start_xy = rand(2, 1) * n;
    segment_length = rand * 600;
    segments_xy = RandomPointsInUnitCircle(num_segments) * segment_length;
    vertices_xy = cumsum([start_xy, segments_xy], 2);
    vertices_xy = reshape(vertices_xy, 1, []);
    width = randi(5);
    % Note: the 'Opacity' option doesn't apply to lines, so we have to change the
    % line color to achieve a similar effect. Also note that [0.5 .. 1] opacity
    % maps to [0.5 .. 0] in color values.
    color = rand * 0.5;
    im = insertShape(im, 'Line', vertices_xy, 'LineWidth', width, ...
        'Color', [color, color, color]);
end

im = rgb2gray(im);

end

function xy = RandomPointsInUnitCircle(num_points)
r = rand(1, num_points, 'single');
theta = rand(1, num_points, 'single') * 2 * pi;
xy = [r .* cos(theta); r .* sin(theta)];
end